<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->

<section xml:id="actions-sage">
	<title>Sage</title>

	<introduction>
		<p>Groups can be realized in many ways, such as as sets of permutations, as sets of matrices, or as sets of abstract symbols related by certain rules (<q>presentations</q>) and in myriad other ways.  We have concentrated on permutation groups because of their concrete feel, with elements written as functions, and because of their thorough implementation in Sage.  Group actions are of great interest when the set they act on is the group itself, and group actions will figure prominently in the proofs of the main results of the next chapter.  However, any time we have a group action on a set, we can view that group as a permutation group on the elements of the set.  So permutation groups are an area of group theory of independent interest, with its own definitions and theorems.</p>

		<p>We will describe Sage's commands applicable when a group action arises naturally via conjugation, and then move into the more general situation in a more general application.</p>
	</introduction>

	<subsection>
		<title>Conjugation as a Group Action</title>

		<p>We might think we need to be careful how Sage defines conjugation (<m>gxg^{-1}</m> versus <m>g^{-1}xg</m>) and the difference between Sage and the text on the order of products.  However, if you look at the definition of the center and centralizer subgroups you can see that any difference in ordering is irrelevant.  Here are the group action commands for the particular action that is conjugation of the elements of the group.</p>

		<p>Sage has a permutation group method <c>.center()</c> which returns the subgroup of fixed points.  The permutation group method, <c>.centralizer(g)</c>, returns a subgroup that is the stabilizer of the group element <c>g</c>.  Finally, the orbits are given by conjugacy classes, but Sage will not flood you with the full conjugacy classes and instead gives back a list of one element per conjugacy class, the representatives, via the permutation group method <c>.conjugacy_classes_representatives()</c>.  You can manually reconstruct a conjugacy class from a representative, as we do in the example below.</p>

		<p>Here is an example of the above commands in action.  Notice that an abelian group would be a bad choice for this example.</p>

		<sage>
		<input>
		D = DihedralGroup(8)
		C = D.center(); C
		</input>
		<output>
		Subgroup of (Dihedral group of order 16 as a permutation group)
		generated by [(1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		C.list()
		</input>
		<output>
		[(), (1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		a = D("(1,2)(3,8)(4,7)(5,6)")
		C1 = D.centralizer(a); C1.list()
		</input>
		<output>
		[(), (1,2)(3,8)(4,7)(5,6), (1,5)(2,6)(3,7)(4,8), (1,6)(2,5)(3,4)(7,8)]
		</output>
		</sage>

		<sage>
		<input>
		b = D("(1,2,3,4,5,6,7,8)")
		C2 = D.centralizer(b); C2.order()
		</input>
		<output>
		8
		</output>
		</sage>

		<sage>
		<input>
		CCR = D.conjugacy_classes_representatives(); CCR
		</input>
		<output>
		[(), (2,8)(3,7)(4,6), (1,2)(3,8)(4,7)(5,6), (1,2,3,4,5,6,7,8),
		 (1,3,5,7)(2,4,6,8), (1,4,7,2,5,8,3,6), (1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		r = CCR[2]; r
		</input>
		<output>
		(1,2)(3,8)(4,7)(5,6)
		</output>
		</sage>

		<sage>
		<input>
		conj = []
		x = [conj.append(g^-1*r*g) for g in D if not g^-1*r*g in conj]
		conj
		</input>
		<output>
		[(1,2)(3,8)(4,7)(5,6), (1,8)(2,7)(3,6)(4,5), (1,4)(2,3)(5,8)(6,7),
		 (1,6)(2,5)(3,4)(7,8)]
		</output>
		</sage>

		<p>Notice that in the one conjugacy class constructed all the elements have the same cycle structure, which is no accident.  Notice too that <c>rep</c> and <c>a</c> are the same element, and the product of the order of the centralizer (<m>4</m>) and the size of the conjugacy class (<m>4</m>) equals the order of the group (<m>16</m>), which is a variant of the conclusion of Theorem<nbsp /><xref ref="theorem-orbit" />.</p>

		<p>Verify that the following is a demonstration of the class equation in the special case when the action is conjugation, but would be valid for any group, rather than just <c>D</c>.</p>

		<sage>
		<input>
		sizes = [D.order()/D.centralizer(g).order()
		             for g in D.conjugacy_classes_representatives()]
		sizes
		</input>
		<output>
		[1, 4, 4, 2, 2, 2, 1]
		</output>
		</sage>

		<sage>
		<input>
		D.order() == sum(sizes)
		</input>
		<output>
		True
		</output>
		</sage>

	</subsection>

	<todo>Construct a general n beads, m colors enumeration example (any of this in Sage already?)</todo>

	<subsection>
		<title>Graph Automorphisms</title>

		<p>As mentioned, group actions can be even more interesting when the set they act on is different from the group itself.  One class of examples is the group of symmetries of a geometric solid, where the objects in the set are the vertices of the object, or perhaps some other aspect such as edges, faces or diagonals.  In this case, the group is all those permutations that move the solid but leave it filling the same space before the motion (<q>rigid motions</q>).</p>

		<p>In this section we will examine something very similar.  A <term>graph</term> is a mathematical object, consisting of vertices and edges, but the only structure is whether or not any given pair of vertices are joined by an edge or not.  The group consists of permutations of vertices that preserve the structure, that is, permutations of vertices that take edges to edges and non-edges to non-edges.  It is very similar to a symmetry group, but there is no notion of any geometric relationships being preserved.</p>

		<p>Here is an example.  You will need to run the first compute cell to define the graph and get a nice graphic representation.</p>

		<sage doctest="not tested">
		<input>
		Q = graphs.CubeGraph(3)
		Q.plot(layout='spring')
		</input>
		</sage>

		<sage>
		<input>
		A = Q.automorphism_group()
		A.order()
		</input>
		<output>
		48
		</output>
		</sage>

		<p>Your plot should look like the vertices and edges of a cube, but may not quite look regular, which is fine, since the geometry is not relevant.  Vertices are labeled with strings of three binary digits, <m>0</m> or <m>1</m>, and any two vertices are connected by an edge if their strings differ in exactly one location.  We might expect the group of symmetries to have order <m>24</m>, rather than order <m>48</m>, given its resemblance to a cube (in appearance and in name).  However, when not restricted to rigid motions, we have new permutations that preserve edges.  One in particular is to interchange two <q>opposite faces.</q>  Locate two <m>4</m>-cycles opposite of each other, listed in the same order:  <m>000, 010, 110, 100</m> and <m>001, 011, 111, 101</m>.  Notice that each cycle looks very similar, but all the vertices of the first end in a zero and the second cycle has vertices ending in a one.</p>

		<p>We can create explicitly the permutation that interchanges these two opposite faces, using a text version of the permutation in cycle notation.</p>

		<sage>
		<input>
		a = A("('000','001')('010','011')('110','111')('100','101')")
		a in A
		</input>
		<output>
		True
		</output>
		</sage>

		<p>We can use this group to illustrate the relevant Sage commands for group actions.</p>

		<sage>
		<input>
		A.orbits()
		</input>
		<output>
		[['000', '001', '010', '100', '011', '101', '110', '111']]
		</output>
		</sage>

		<p>So this action has only one (big) orbit.  This implies that every vertex is <q>like</q> any other.  When a permutation group behaves this way, we say the group is <term>transitive</term>.</p>

		<sage>
		<input>
		A.is_transitive()
		</input>
		<output>
		True
		</output>
		</sage>

		<p>If every vertex is <q>the same</q> we can compute the stabilizer of any vertex, since they will all be isomorphic.  Because vertex <m>000</m> is the simplest in some sense, we compute its stabilizer.</p>

		<sage>
		<input>
		S = A.stabilizer('000')
		S.list()
		</input>
		<output>
		[(),
		 ('010','100')('011','101'),
		 ('001','010')('101','110'),
		 ('001','010','100')('011','110','101'),
		 ('001','100','010')('011','101','110'),
		 ('001','100')('011','110')]
		</output>
		</sage>

		<p>That <c>S</c> has <m>6</m> elements is no surprise, since the group has order <m>48</m> and the size of the lone orbit is <m>8</m>.  But we can go one step further.  The three vertices of the graph attached directly to <m>000</m> are <m>100</m>, <m>010</m>, <m>001</m>.  Any automorphism of the graph that fixes <m>000</m> must then permute the three adjacent vertices.  There are <m>3!=6</m> possible ways to do this, and you can check that each appears in one of the six elements of the stabilizer.  So we can understand a transitive group by considering the smaller stabilizer, and in this case we can see that each element of the stabilizer is determined by how it permutes the neighbors of the stabilized vertex.</p>

		<p>Transitive groups are both unusual and important.  To contrast, here is a graph automorphism group that is far from transitive (without being trivial).  A path is a graph that has all of its vertices in a line.  Run the first compute cell to see a path on <m>11</m> vertices.</p>

		<sage doctest="not tested">
		<input>
		P = graphs.PathGraph(11)
		P.plot()
		</input>
		</sage>

		<sage>
		<input>
		A = P.automorphism_group()
		A.list()
		</input>
		<output>
		[(), (0,10)(1,9)(2,8)(3,7)(4,6)]
		</output>
		</sage>

		<p>The automorphism group is the trivial identity automorphism (always) and an order <m>2</m> permutation that <q>flips</q> the path end-to-end.  The group is far from transitive and there are many orbits.</p>

		<sage>
		<input>
		A.is_transitive()
		</input>
		<output>
		False
		</output>
		</sage>

		<sage>
		<input>
		A.orbits()
		</input>
		<output>
		[[0, 10], [1, 9], [2, 8], [3, 7], [4, 6], [5]]
		</output>
		</sage>

		<p>Most of the stabilizers are trivial, with one exception.  As subgroups of a group of order <m>2</m>, there really are not too many options.</p>

		<sage>
		<input>
		A.stabilizer(2).list()
		</input>
		<output>
		[()]
		</output>
		</sage>

		<sage>
		<input>
		A.stabilizer(5).list()
		</input>
		<output>
		[(), (0,10)(1,9)(2,8)(3,7)(4,6)]
		</output>
		</sage>

		<p>How would this final example have been different if we had used a path on <m>10</m> vertices?</p>

		<p><em>NOTE</em>: There was once a small bug with stabilizers being created as subgroups of symmetric groups on fewer symbols than the correct number.  This is fixed in Sage 4.8 and newer.  Note the correct output below, and you can check your installation by running these commands.  If you do not see the singleton <c>[4]</c> in your output, you should definitely update your copy of Sage.</p>

		<sage>
		<input>
		G = SymmetricGroup(4)
		S = G.stabilizer(4)
		S.orbits()
		</input>
		<output>
		[[1, 3, 2], [4]]
		</output>
		</sage>

	</subsection>
</section>