<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 1997-2014  Thomas W. Judson     -->
<!-- See the file COPYING for copying conditions.  -->

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->


Since Sage began as software to support research in number theory, we can quickly and easily demonstrate the internal workings of the RSA algorithm.  Recognize that, in practice, many other details such as encoding between letters and integers, or protecting one's private key, are equally important for the security of communications.  So RSA itself is just the theoretical foundation.


</subsection>
<subsection>
<title>Constructing Keys</title>

We will suppose that Alice wants to send a secret message to Bob, along with message verification (also known as a message with a digital signature).  So we begin with the construction of key pairs (private and public) for both Alice and Bob.  We first need two large primes for both individuals, and their product.  In practice, values of <m>n</m> would have hundreds of digits, rather than just <m>21</m> as we have done here.

<sage>
<input>
sage: p_a = next_prime(10^10)
sage: q_a = next_prime(p_a)
sage: p_b = next_prime((3/2)*10^10)
sage: q_b = next_prime(p_b)
sage: n_a = p_a * q_a
sage: n_b = p_b * q_b
sage: n_a, n_b
(100000000520000000627, 225000000300000000091)
</input>
<output>
</output>
</sage>

Computationally, the value of the Euler <m>\phi</m>-function for a product of primes <m>pq</m> can be obtained from <m>(p-1)(q-1)</m>, but we could use Sage's built-in function just as well.

<sage>
<input>
sage: m_a = euler_phi(n_a)
sage: m_b = euler_phi(n_b)
sage: m_a, m_b
(100000000500000000576, 225000000270000000072)
</input>
<output>
</output>
</sage>

Now we can create the encryption and decryption exponents.  We choose the encryption exponent as a (small) number relatively prime to the value of <m>m</m>.  With Sage we can factor <m>m</m> quickly to help us choose this value.  In practice we would not want to do this computation for large values of <m>m</m>, so we might more easily choose <q>random</q> values and check for the first value which is relatively prime to <m>m</m>.  The decryption exponent is the multiplicaive inverse, mod <m>m</m>, of the encryption exponent.  If you construct an improper encryption exponent (not relatively prime to <m>m</m>), the computation of the multiplicative inverse will fail (and Sage will tell you so).  We do this twice <mdash />- for both Alice and Bob.

<sage>
<input>
sage: factor(m_a)
2^6 * 3 * 11 * 17 * 131 * 521 * 73259 * 557041
sage: E_a = 5*23
sage: D_a = inverse_mod(E_a, m_a)
sage: D_a
20869565321739130555
</input>
<output>
</output>
</sage>

<sage>
<input>
sage: factor(m_b)
2^3 * 3^4 * 107 * 1298027 * 2500000001
sage: E_b = 7*29
sage: D_b = inverse_mod(E_b, m_b)
sage: D_b
24384236482463054195
</input>
<output>
</output>
</sage>

At this stage, each individual would publish their values of <m>n</m> and <m>E</m>, while keeping <m>D</m> very private and secure.  In practice <m>D</m> might be protected on the user's hard disk (or USB thumb drive they always carry with them) by a password only they know.  Every time the person uses <m>D</m> they would need to provide the password.  The value of <m>m</m> can be discarded.  So for the record, here are all the keys:

<sage>
<input>
sage: print "Alice's public key, n:", n_a, " E:", E_a
Alice's public key, n: 100000000520000000627  E: 115
sage: print "Alice's private key, D:", D_a
Alice's private key, D: 20869565321739130555
</input>
<output>
</output>
</sage>

<sage>
<input>
sage: print "Bob's public key, n:", n_b, " E:", E_b
Bob's public key, n: 225000000300000000091  E: 203
sage: print "Bob's private key, D:", D_b
Bob's private key, D: 24384236482463054195
</input>
<output>
</output>
</sage>


</subsection>
<subsection>
<title>Signing and Encoding a Message</title>

Alice is going to construct a message as an English word with four letters.  From these four letters we will construct a single number to represent the message in a form we can use in the RSA algorithm.  The function <c>ord()</c> will convert a single letter to its ASCII code value, a number between 0 and 127.  If we use these numbers as <q>digits</q> mod 128, we can be sure that Alice's four-letter word will encode to an integer less than <m>128^4=268,435,456</m>.  The particular maximum value is not important, so long as it is smaller than our value of <m>n</m> since all of our subsequent arithmetic is mod <m>n</m>.  We choose a popular four-letter word, convert to ASCII <q>digits</q> with a list comprehension, and then construct the integer from the digits with the right base.  Notice how we can treat the word as a list and that the first digit in the list is in the <q>ones</q> place (we say the list is being treated as in <q>little-endian</q> order).

<sage>
<input>
sage: word = 'Sage'
sage: digits = [ord(letter) for letter in word]
sage: digits
[83, 97, 103, 101]
sage: message = ZZ(digits, 128)
sage: message
213512403
</input>
<output>
</output>
</sage>

First, Alice will sign her message to provide message verification.  She uses her private key for this, since this is an act that only she should be able to perform.

<sage>
<input>
sage: signed = power_mod(message, D_a, n_a)
sage: signed
47838774644892618423
</input>
<output>
</output>
</sage>

Then Alice encrypts her message so that only Bob can read it.  To do this, she uses Bob's public key.  Notice how she does not have to even know Bob <mdash /> for example, she could have obtained Bob's public key off his web site.

<sage>
<input>
sage: encrypted = power_mod(signed, E_b, n_b)
sage: encrypted
111866209291209840488
</input>
<output>
</output>
</sage>

Alice's communication is now ready to travel on any communications network, no matter how insecure it might be.


</subsection>
<subsection>
<title>Decoding and Verifying a Message</title>

Now assume that the value of <c>encrypted</c> has reached Bob.  Realize that Bob may not know Alice, and realize that Bob does not even necessarily believe what he has received has genuinely originated from Alice.  An adversary could be trying to confuse Bob by sending messages that claim to be from Alice.  First, Bob must unwrap the encyption Alice has provided.  This is an act only Bob, as the intended recipient, should be able to do.  And he does it by using his private key, which only he knows, and which he has kept securely in his possession.

<sage>
<input>
sage: decrypted = power_mod(encrypted, D_b, n_b)
sage: decrypted
47838774644892618423
</input>
<output>
</output>
</sage>

Right now, this means very little to Bob.  Anybody could have sent him an encoded message.  However, this was a message Alice signed.  Lets unwrap the message signing.  Notice that this uses Alice's public key.  Bob does not need to know Alice <mdash /> for example, he could obtain Alice's key off her web site.

<sage>
<input>
sage: received = power_mod(decrypted, E_a, n_a)
sage: received
213512403
</input>
<output>
</output>
</sage>

Bob needs to transform this integer representation back to a word with letters.  The <c>chr()</c> function converts ASCII code values to letters, and we use a list comprehension to do this repeatedly.

<sage>
<input>
sage: digits = received.digits(base=128)
sage: letters = [chr(ascii) for ascii in digits]
sage: letters
['S', 'a', 'g', 'e']
</input>
<output>
</output>
</sage>

If we would like a slightly more recognizable result, we can combine the letters into a string.

<sage>
<input>
sage: </q>.join(letters)
'Sage'
</input>
<output>
</output>
</sage>

Bob is pleased to obtain such an informative message from Alice.  What would have happened if an imposter had sent a message ostensibly from Alice, or what if an adversary had intercepted Alice's original message and replaced it with a tampered message?  (The latter is known as a <q>man in the middle</q> attack.)

In either case, the rogue party would not be able to duplicate Alice's first action <mdash /> signing her message.  If an adversary somehow signs the message, or tampers with it, the step where Bob unwraps the signing will lead to total garbage.  (Try it!)  Because Bob received a legitimate word, properly capitalized, he has confidence that the message he unsigned is the same as the message Alice signed.  In practice, if Alice sent several hundred words as her message, the odds that it will unsign as cohrent text are astronomically small.

What have we demonstrated?

\begin{enumerate}
</li><li> Alice can send messages only Bob can read.
</li><li> Bob can receive secret messages from anybody.
</li><li> Alice can sign messages, so Bob knows they come from Alice.
\end{enumerate}

Of course, without making new keys, you can reverse the roles of Alice and Bob.  And if Carol makes a key pair, she can communicate with both Alice and Bob in the same fashion.

If you want to use RSA public-key encryption seriously, investigate the open source software GNU Privacy Guard, aka <c>GPG</c>.

